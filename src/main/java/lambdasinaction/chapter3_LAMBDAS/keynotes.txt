
1. A lambda expression can be understood as a concise representation of an anonymous function
   that can be passed around: it doesn’t have a name, but it has a list of parameters, a body, a
   return type, and also possibly a list of exceptions that can be thrown.

2.  The basic syntax of a lambda is either
   (parameters) -> expression
    OR
   (parameters) -> { statements; }

3. In a nutshell, a functional interface is an interface that specifies exactly one abstract method.
   An interface is still a functional interface if it has many default methods as long as it specifies only one abstract method.

4. Lambda expressions let you provide the implementation of the abstract method of a functional interface directly inline and treat the
   whole expression as an instance of a functional interface. The signature of the abstract method of the functional interface essentially
   describes the signature of the lambda expression. We call this abstract method a function descriptor.
        A lambda expression can be assigned to a variable or passed to a method expecting a functional interface as argument, provided the
   lambda expression has the same signature as the abstract method of the functional interface.

5. Note that the @FunctionalInterface annotation isn’t mandatory, but it’s good practice to use it when an interface is designed for that purpose.
   You can think of it like the @Override notation to indicate that a method is overridden

Predefined functional interfaces :

6. PREDICATE : The java.util.function.Predicate<T> interface defines an abstract method named TEST that accepts an object of
               generic type T and returns a BOOLEAN.(ideal for FILTERING)

7. CONSUMER: The java.util.function.Consumer<T> interface defines an abstract method named ACCEPT that takes an object of generic
             type T and returns no result (void).You might use this interface when you need to access an object of type T and perform
             some operations on it.
   SUPPLIER: () -> T [are metoda GET]
8. FUNCTION : The java.util.function.Function<T, R> interface defines an abstract method named APPLY that takes an object of generic type T
    as input and returns an object of generic type R. You might use this interface when you need to define a lambda that maps information
    from an input object to an output (for example, extracting the weight of an apple or mapping a string to its length).

**Java 8 brings a specialized version of the functional interfaces we described earlier in order to avoid autoboxing operations when the
inputs or outputs are primitives. For example, in the following code, using an IntPredicate avoids a boxing operation of the value 1000,
whereas using a Predicate<Integer> would box the argument 1000 to an Integer object.

9. Method references let you reuse existing method definitions and pass them just like lambdas. In some cases they appear more readable and
 feel more natural than using lambda expressions.

10. Functional interfaces such as Comparator, Predicate, and Function have several default methods that can be used to combine lambda expressions.


